from typing import List, Dict, Any, Union

from da4vid.model.proteins import Protein, NestedDict


class FoldMetrics:
  """
  Abstracts metrics related to a fold.
  """
  def __init__(self, fold, metrics: Dict[str, Any] = None):
    """
    Creates the metrics for the fold.
    :param fold: The fold these metrics are related
    :param metrics: A dictionary with metrics
    """
    self.fold = fold
    self.metrics = NestedDict(metrics)

  def add_metric(self, key: str, value: Any) -> None:
    """
    Adds a new metric to this set of metrics, by specifying a
    dot-separated string for the property.
    :param key: The key on which store this metric. If the key
                is already present, it will be overwritten
    :param value: The value of desired metric
    """
    self.metrics.add_value(key, value)

  def get_metric(self, key: str) -> Any:
    """
    Retrieves a specific metric given a dot-separated key.
    :param key: The key with the path to the desired value
    :return: The value linked to the given key, or None if
             the key has not been found
    """
    return self.metrics.get_value(key)


class Sequence:
  """
  Abstracts a sequence entity during the sampling process.
  """
  def __init__(self, name: str, filepath: str = None, sample=None, protein: Protein = None):
    """
    Creates a new sequence.
    :param name: Sequence's name
    :param filepath: Path to file in which sequence is stored (usually a FASTA file)
    :param sample: The sample this sequence has been extracted
    :param protein: The protein object resembling the sequence
    """
    self.name = name
    self.filepath = filepath
    self.sample = sample
    self.protein = protein
    self.__folds = {}

  def folds(self) -> List['Fold']:
    """
    Gets the list of all folds for this sequence.
    :return: A list of Fold objects related to this sequence
    """
    return list(self.__folds.values())

  def add_folds(self, folds: 'Fold' | List['Fold']) -> None:
    """
    Adds a new fold to this sequence.
    :param folds: The fold which has to be added or the list of folds to add
    """
    if not isinstance(folds, list):
      folds = [folds]
    self.__folds |= {f.model: f for f in folds}
    for fold in folds:  # Updating sequence in folds
      fold.sequence = self

  def sequence_to_str(self) -> str:
    """
    Returns the AA residue sequence.
    :return: The AA sequence in one-letter notation
    """
    return self.protein.sequence()

  def get_fold_for_model(self, model: str) -> Union['Fold', None]:
    """
    Gets the fold object predicted by the specified model.
    :param model: The name of the model which generated the fold
    :return: The fold predicted by the model or None if no fold
             generated by that model is present
    """
    return self.__folds.get(model, None)


class Sample:
  """
  Abstracts a new sampling target for the pipeline.
  """
  def __init__(self, name: str, filepath: str = None, protein: Protein = None):
    """
    Creates a new sample.
    :param name: The name of the sample
    :param filepath: The path to the file in which this sample is stored
                     (typically a file in PDB format)
    :param protein: The protein object resembling this sample
    """
    self.name = name
    self.filepath = filepath
    self.protein = protein
    self.base = None  # TODO: Remember why I put this here
    self.__sequences: Dict[str, Sequence] = {}

  def add_sequences(self, sequences: Sequence | List[Sequence]):
    """
    Adds a new Sequence object to this sample.
    :param sequences: The sequence being added or the list of sequences to add
    """
    if isinstance(sequences, Sequence):
      sequences = [sequences]
    self.__sequences |= {s.name: s for s in sequences}
    for sequence in sequences:  # Updating sequences' sample
      sequence.sample = self

  def sequences(self) -> List[Sequence]:
    """
    Gets the list of all sequences for this sample.
    :return: A list of sequence objects related to this sample
    """
    return list(self.__sequences.values())

  def get_sequence_by_name(self, name: str) -> Sequence | None:
    """
    Gets a sequence by its name in this sample.
    :param name: The name of the searched sequence
    :return: The sequence with the given name or None if there is
             no sequence with that name
    """
    return self.__sequences.get(name, None)

  def remove_duplicate_sequences(self) -> None:
    """
    Removes all duplicate sequences from this sample.
    """
    unique = []
    seen = set()
    for sequence in self.__sequences.values():
      str_seq = sequence.sequence_to_str()
      if str_seq not in seen:
        seen.add(str_seq)
        unique.append(sequence)
    self.__sequences = {s.name: s for s in unique}

  def get_folds_for_model(self, model: str) -> List['Fold']:
    return [s.get_fold_for_model(model) for s in self.__sequences.values()
            if s.get_fold_for_model(model) is not None]


class Fold(Sample):
  """
  Abstracts a folding object obtained in validation phase. The folding
  can be used as samples for other iterations.
  """

  def __init__(self, sequence: Sequence, filepath: str,
               model: str, protein: Protein = None, metrics: Dict[str, Any] = None):
    """
    Creates the fold object, with any associated metrics.
    :param sequence: The sequence to which this fold relates, which determines
                     also the folding name
    :param filepath: The file in which the fold is stored (typically a PDB file)
    :param model: The model used to predict this fold (e.g., OmegaFold, AlphaFold, ...)
    :param protein: The protein object resembling this fold
    :param metrics: The dictionary of metrics related to the fold
    """
    super().__init__(sequence.name, filepath)
    self.sequence = sequence
    self.model = model
    self.protein = protein
    self.metrics = FoldMetrics(self, metrics)


class SampleSet:
  """
  Abstract a set of samples.
  """

  def __init__(self):
    self.__samples: Dict[str, Sample] = {}

  def add_samples(self, samples: Sample | List[Sample]) -> None:
    """
    Adds a new sample to this set.
    :param samples: The sample being added or a list of samples to add
    """
    if isinstance(samples, Sample):
      samples = [samples]
    self.__samples |= {sample.name: sample for sample in samples}

  def samples(self) -> List[Sample]:
    """
    Gets all samples in the set.
    :return: A list of all samples in this set
    """
    return list(self.__samples.values())

  def get_sample_by_name(self, name: str) -> Sample | None:
    """
    Gets a sample with specified name belonging to this set.
    :param name: The name of the desired sample
    :return: The sample or None if no sample with that name
             is present
    """
    return self.__samples.get(name, None)

  def folded_sample_set(self, model: str):
    """
    Creates a new sample set containing all folds sampled with
    the given model for each sample and sequence in this sample set.
    :param model: The model whose folds are going to be included in
                  the new sample set
    :return: A SampleSet object containing all retrieved folds
    """
    new_set = SampleSet()
    for sample in self.__samples.values():
      new_set.add_samples(sample.get_folds_for_model(model))
    return new_set

  def sequences(self) -> List[Sequence]:
    """
    Retrieves all sequences for all the samples in this set.
    :return: The list of all sequence objects related to samples
    """
    return [seq for sample in self.samples() for seq in sample.sequences()]

  def get_sequence_by_name(self, name: str) -> Sequence | None:
    """
    Gets a sequence in this sample set with the given name, if it exists.
    :param name: The name of the sequence to search for
    :return: The sequence with the given name, or None if no sequence
             in this set has the provided name
    """
    for sample in self.__samples.values():
      for sequence in sample.sequences():
        if sequence.name == name:
          return sequence
    return None
